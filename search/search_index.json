{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python Tips and Tricks \u00b6 Este reposit\u00f3rio cont\u00e9m um conjunto de Jupyter Notebooks que explicam sobre Python, programa\u00e7\u00e3o orientada \u00e0 objetos em Python, dicas, truques, boas pr\u00e1ticas e receitas. O trabalho ainda est\u00e1 em progresso. Portanto, erros ser\u00e3o corrigidos e melhorias adicionadas \u00e0 medida que o trabalho avan\u00e7ar. Caso queira contribuir com sugest\u00f5es, sinta-se \u00e0 vontade para abrir Issues & PRs!","title":"In\u00edcio"},{"location":"#python-tips-and-tricks","text":"Este reposit\u00f3rio cont\u00e9m um conjunto de Jupyter Notebooks que explicam sobre Python, programa\u00e7\u00e3o orientada \u00e0 objetos em Python, dicas, truques, boas pr\u00e1ticas e receitas. O trabalho ainda est\u00e1 em progresso. Portanto, erros ser\u00e3o corrigidos e melhorias adicionadas \u00e0 medida que o trabalho avan\u00e7ar. Caso queira contribuir com sugest\u00f5es, sinta-se \u00e0 vontade para abrir Issues & PRs!","title":"Python Tips and Tricks"},{"location":"about/","text":"Sobre o Autor \u00b6 Ol\u00e1, meu nome \u00e9 Alisson! Tenho 24 anos, sou formado em Ci\u00eancia da Computa\u00e7\u00e3o na Universidade Federal S\u00e3o Carlos e atualmente trabalho como Engenheiro de Dados no iFood . Como voc\u00ea j\u00e1 deve saber, ensinar \u00e9 a melhor forma de aprender e este projeto tem exatamente essa inten\u00e7\u00e3o! Todo o conte\u00fado presente aqui tem como objetivo ser um caderno de notas e resumos \\(-\\) de guia pessoal \\(-\\) sobre os principais t\u00f3picos relacionados a Programa\u00e7\u00e3o e Python. Al\u00e9m disso, dado o car\u00e1ter pessoal, pe\u00e7o que n\u00e3o se estresse ou fique chateado caso a did\u00e1tica seja ruim e o conte\u00fado esteja mal organizado e faltante, afinal o conte\u00fado n\u00e3o visa servir como refer\u00eancia ou material de ensino, mas sim como um guia pessoal! Por\u00e9m, ao mesmo tempo, caso encontre quaisquer erros, por favor entre em contato comigo e irei corrigi-los o mais r\u00e1pido poss\u00edvel (e voc\u00ea tamb\u00e9m estar\u00e1 me ajudando a aprender mais!). Enfim, divirta-se navegando pelo meu conhecimento!","title":"Sobre o Autor"},{"location":"about/#sobre-o-autor","text":"Ol\u00e1, meu nome \u00e9 Alisson! Tenho 24 anos, sou formado em Ci\u00eancia da Computa\u00e7\u00e3o na Universidade Federal S\u00e3o Carlos e atualmente trabalho como Engenheiro de Dados no iFood . Como voc\u00ea j\u00e1 deve saber, ensinar \u00e9 a melhor forma de aprender e este projeto tem exatamente essa inten\u00e7\u00e3o! Todo o conte\u00fado presente aqui tem como objetivo ser um caderno de notas e resumos \\(-\\) de guia pessoal \\(-\\) sobre os principais t\u00f3picos relacionados a Programa\u00e7\u00e3o e Python. Al\u00e9m disso, dado o car\u00e1ter pessoal, pe\u00e7o que n\u00e3o se estresse ou fique chateado caso a did\u00e1tica seja ruim e o conte\u00fado esteja mal organizado e faltante, afinal o conte\u00fado n\u00e3o visa servir como refer\u00eancia ou material de ensino, mas sim como um guia pessoal! Por\u00e9m, ao mesmo tempo, caso encontre quaisquer erros, por favor entre em contato comigo e irei corrigi-los o mais r\u00e1pido poss\u00edvel (e voc\u00ea tamb\u00e9m estar\u00e1 me ajudando a aprender mais!). Enfim, divirta-se navegando pelo meu conhecimento!","title":"Sobre o Autor"},{"location":"references/","text":"","title":"References"},{"location":"development_practices/","text":"Pr\u00e1ticas de Desenvolvimento \u00b6","title":"Pr\u00e1ticas de Desenvolvimento"},{"location":"development_practices/#praticas-de-desenvolvimento","text":"","title":"Pr\u00e1ticas de Desenvolvimento"},{"location":"development_practices/how_document_applications/","text":"Como documentar aplica\u00e7\u00f5es \u00b6 Aten\u00e7\u00e3o! Este documento apenas descreve como eu documento minhas aplica\u00e7\u00f5es. Existem diversas estrat\u00e9gias e modelos dispon\u00edveis, \u00e9 claro. Mas, esse padr\u00e3o \u00e9 o que tem se encaixado melhor at\u00e9 o momento (logo, \u00e9 muito prov\u00e1vel que o padr\u00e3o apresentado aqui evolua com o tempo). Ao documentar um software, precisamos ter em mente principalmente quem \u00e9 o p\u00fablico-alvo. Por exemplo, \u00e9 uma documenta\u00e7\u00e3o para: Usu\u00e1rio? Desenvolvedor? Stakeholder? Todos? Podemos dividir os tipos de documenta\u00e7\u00e3o em: Projeto de Sistema de Software. Documenta\u00e7\u00e3o onde s\u00e3o abordados os problemas que o software busca resolver, a(s) solu\u00e7\u00e3o(\u00f5es) propostas, diagrama explicado do sistema tanto alto-n\u00edvel (componentes em uma vis\u00e3o mais geral) e baixo n\u00edvel (i.e. diagrama de classes, etc.) P\u00fablico-alvo. Desenvolvedores e stakeholders. Documenta\u00e7\u00e3o de Uso . Documenta\u00e7\u00e3o onde s\u00e3o apresentadas as funcionalidades da ferramenta, assim como utilizar cada uma dessas ferramentas. Aqui, tamb\u00e9m podem ser incluidas se\u00e7\u00f5es sobre idealiza\u00e7\u00e3o da ferramenta, problemas que a aplica\u00e7\u00e3o busca solucionar, etc. P\u00fablico-alvo. Usu\u00e1rios, desenvolvedores e stakeholders. Projeto de Sistema de Software \u00b6 Uma documenta\u00e7\u00e3o de projeto de sistema de software tipo deve ter as seguintes se\u00e7\u00f5es: Introdu\u00e7\u00e3o. Apresenta\u00e7\u00e3o do problema a ser resolvido (incluindo o porqu\u00ea de ser um problema.) Proposta. Apresenta\u00e7\u00e3o da proposta/aplica\u00e7\u00e3o a ser desenvolvida, incluindo como ela resolve os problemas definidos na Introdu\u00e7\u00e3o, funcionalidades e qualidades em geral. Arquitetura do Sistema (Alto N\u00edvel). Diagrama do sistema em uma vis\u00e3o de alto-n\u00edvel, ou seja como diferentes componentes ao n\u00edvel de ferramentas interagem entre si. Arquitetura do Sistema (Baixo N\u00edvel). Diagrama do sistema em uma vis\u00e3o de mais baixo-n\u00edvel, descrevendo como os componentes em si podem ser implementados. Conclus\u00e3o. Palavras finais em rela\u00e7\u00e3o as expectativas do projeto e os impactos que o sucesso da aplica\u00e7\u00e3o pode gerar. Nota Os t\u00edtulos das se\u00e7\u00f5es n\u00e3o precisam, necessariamente, serem os descritos aqui. Documenta\u00e7\u00e3o de Uso \u00b6 Uma documenta\u00e7\u00e3o de uso pode ser simples ou complexa. Simples. Documentada em um arquivo Markdown junto do reposit\u00f3rio do projeto ( README.md ) Complexa. Documenta\u00e7\u00e3o com se\u00e7\u00f5es dedicadas ao usu\u00e1rio e ao desenvolvedor (onde s\u00e3o documentados os componente do sistema em diferentes n\u00edveis de complexidade). Geralmente, definida em arquivos HTML. Simples \u00b6 As se\u00e7\u00f5es de uma documenta\u00e7\u00e3o de uso simples s\u00e3o: Sobre . Apresenta\u00e7\u00e3o da aplica\u00e7\u00e3o (e, opcionalmente, o problema que visa resolver). Pr\u00e9-requisitos (Requisitos). Aplica\u00e7\u00f5es ou pacotes que devem estar j\u00e1 presentes para o uso e instala\u00e7\u00e3o da aplica\u00e7\u00e3o. Instala\u00e7\u00e3o. Guia de instala\u00e7\u00e3o da aplica\u00e7\u00e3o Quickstart. Um exemplo r\u00e1pido e simples de uso da ferramenta Especifica\u00e7\u00f5es. Explica\u00e7\u00f5es sobre as funcionalidades do sistema, incluindo a intere\u00e7\u00e3o entre as diferentes funcionalidades e o workflow geral. Exemplos. Exemplos de uso da ferramenta em diferentes cen\u00e1rios. Complexa \u00b6 As se\u00e7\u00f5es de uma documenta\u00e7\u00e3o de uso complexa s\u00e3o: Getting started. Installation (and pre-requisistes) Quickstart Why? FAQ Changelog User Guide. API Reference. Developer Guide. Contributing Bug report Feature requests Architecture Overview Al\u00e9m disso, deve haver um README.md no reposit\u00f3rio do projeto, onde s\u00e3o apresentadas refer\u00eancias para as respectivas se\u00e7\u00f5es na documenta\u00e7\u00e3o. Ainda, pode-se usar o Sphinx para a documenta\u00e7\u00e3o autom\u00e1tica da API, demais docstrings e arquivos .rst (ou .md ). O Sphinx cont\u00e9m diversos temas interessantes que podem ser utilizados. Alguns exemplos s\u00e3o: https://sphinx-themes.org/sample-sites/furo/ https://sphinx-themes.org/sample-sites/sphinx-book-theme/","title":"Como documentar aplica\u00e7\u00f5es"},{"location":"development_practices/how_document_applications/#como-documentar-aplicacoes","text":"Aten\u00e7\u00e3o! Este documento apenas descreve como eu documento minhas aplica\u00e7\u00f5es. Existem diversas estrat\u00e9gias e modelos dispon\u00edveis, \u00e9 claro. Mas, esse padr\u00e3o \u00e9 o que tem se encaixado melhor at\u00e9 o momento (logo, \u00e9 muito prov\u00e1vel que o padr\u00e3o apresentado aqui evolua com o tempo). Ao documentar um software, precisamos ter em mente principalmente quem \u00e9 o p\u00fablico-alvo. Por exemplo, \u00e9 uma documenta\u00e7\u00e3o para: Usu\u00e1rio? Desenvolvedor? Stakeholder? Todos? Podemos dividir os tipos de documenta\u00e7\u00e3o em: Projeto de Sistema de Software. Documenta\u00e7\u00e3o onde s\u00e3o abordados os problemas que o software busca resolver, a(s) solu\u00e7\u00e3o(\u00f5es) propostas, diagrama explicado do sistema tanto alto-n\u00edvel (componentes em uma vis\u00e3o mais geral) e baixo n\u00edvel (i.e. diagrama de classes, etc.) P\u00fablico-alvo. Desenvolvedores e stakeholders. Documenta\u00e7\u00e3o de Uso . Documenta\u00e7\u00e3o onde s\u00e3o apresentadas as funcionalidades da ferramenta, assim como utilizar cada uma dessas ferramentas. Aqui, tamb\u00e9m podem ser incluidas se\u00e7\u00f5es sobre idealiza\u00e7\u00e3o da ferramenta, problemas que a aplica\u00e7\u00e3o busca solucionar, etc. P\u00fablico-alvo. Usu\u00e1rios, desenvolvedores e stakeholders.","title":"Como documentar aplica\u00e7\u00f5es"},{"location":"development_practices/how_document_applications/#projeto-de-sistema-de-software","text":"Uma documenta\u00e7\u00e3o de projeto de sistema de software tipo deve ter as seguintes se\u00e7\u00f5es: Introdu\u00e7\u00e3o. Apresenta\u00e7\u00e3o do problema a ser resolvido (incluindo o porqu\u00ea de ser um problema.) Proposta. Apresenta\u00e7\u00e3o da proposta/aplica\u00e7\u00e3o a ser desenvolvida, incluindo como ela resolve os problemas definidos na Introdu\u00e7\u00e3o, funcionalidades e qualidades em geral. Arquitetura do Sistema (Alto N\u00edvel). Diagrama do sistema em uma vis\u00e3o de alto-n\u00edvel, ou seja como diferentes componentes ao n\u00edvel de ferramentas interagem entre si. Arquitetura do Sistema (Baixo N\u00edvel). Diagrama do sistema em uma vis\u00e3o de mais baixo-n\u00edvel, descrevendo como os componentes em si podem ser implementados. Conclus\u00e3o. Palavras finais em rela\u00e7\u00e3o as expectativas do projeto e os impactos que o sucesso da aplica\u00e7\u00e3o pode gerar. Nota Os t\u00edtulos das se\u00e7\u00f5es n\u00e3o precisam, necessariamente, serem os descritos aqui.","title":"Projeto de Sistema de Software"},{"location":"development_practices/how_document_applications/#documentacao-de-uso","text":"Uma documenta\u00e7\u00e3o de uso pode ser simples ou complexa. Simples. Documentada em um arquivo Markdown junto do reposit\u00f3rio do projeto ( README.md ) Complexa. Documenta\u00e7\u00e3o com se\u00e7\u00f5es dedicadas ao usu\u00e1rio e ao desenvolvedor (onde s\u00e3o documentados os componente do sistema em diferentes n\u00edveis de complexidade). Geralmente, definida em arquivos HTML.","title":"Documenta\u00e7\u00e3o de Uso"},{"location":"development_practices/how_document_applications/#simples","text":"As se\u00e7\u00f5es de uma documenta\u00e7\u00e3o de uso simples s\u00e3o: Sobre . Apresenta\u00e7\u00e3o da aplica\u00e7\u00e3o (e, opcionalmente, o problema que visa resolver). Pr\u00e9-requisitos (Requisitos). Aplica\u00e7\u00f5es ou pacotes que devem estar j\u00e1 presentes para o uso e instala\u00e7\u00e3o da aplica\u00e7\u00e3o. Instala\u00e7\u00e3o. Guia de instala\u00e7\u00e3o da aplica\u00e7\u00e3o Quickstart. Um exemplo r\u00e1pido e simples de uso da ferramenta Especifica\u00e7\u00f5es. Explica\u00e7\u00f5es sobre as funcionalidades do sistema, incluindo a intere\u00e7\u00e3o entre as diferentes funcionalidades e o workflow geral. Exemplos. Exemplos de uso da ferramenta em diferentes cen\u00e1rios.","title":"Simples"},{"location":"development_practices/how_document_applications/#complexa","text":"As se\u00e7\u00f5es de uma documenta\u00e7\u00e3o de uso complexa s\u00e3o: Getting started. Installation (and pre-requisistes) Quickstart Why? FAQ Changelog User Guide. API Reference. Developer Guide. Contributing Bug report Feature requests Architecture Overview Al\u00e9m disso, deve haver um README.md no reposit\u00f3rio do projeto, onde s\u00e3o apresentadas refer\u00eancias para as respectivas se\u00e7\u00f5es na documenta\u00e7\u00e3o. Ainda, pode-se usar o Sphinx para a documenta\u00e7\u00e3o autom\u00e1tica da API, demais docstrings e arquivos .rst (ou .md ). O Sphinx cont\u00e9m diversos temas interessantes que podem ser utilizados. Alguns exemplos s\u00e3o: https://sphinx-themes.org/sample-sites/furo/ https://sphinx-themes.org/sample-sites/sphinx-book-theme/","title":"Complexa"},{"location":"development_practices/linting/","text":"Linting \u00b6 Introdu\u00e7\u00e3o \u00b6 Durante os momentos de escrita de c\u00f3digo podemos cometer uma s\u00e9rie de erros: Erros de sintaxe. Erros l\u00f3gicos que prejudicam a seguran\u00e7a da aplica\u00e7\u00e3o. Erros de estiliza\u00e7\u00e3o do c\u00f3digo. Por\u00e9m, tais erros s\u00e3o normais de acontecerem e, mesmo com muito esfor\u00e7o, \u00e9 dif\u00edcil encontrarmos todos eles. Portanto, utilizamos ferramentas capazes de analisar e detectar problemas em nossos c\u00f3digos. Essas ferramentas, chamadas de linters, s\u00e3o capazes de checar: Erros l\u00f3gicos (Logical Lint) Erros de sintaxe. Peda\u00e7os de c\u00f3digo com resultados indesejados (bugs). Peda\u00e7os de c\u00f3digo com falhas de seguran\u00e7a. Erros de estiliza\u00e7\u00e3o (Stylistic Lint) C\u00f3digo n\u00e3o alinhado com o Guia de Estilo definido. H\u00e1 tamb\u00e9m outras ferramentas que podemos usar em complemento aos linters que nos ajudam a melhorar a qualidade do c\u00f3digo, como \u00e9 o caso de formatadores autom\u00e1ticos de c\u00f3digo (code formatters). Nem tudo \u00e9 o que parece Na maioria dos casos, os linters que usamos s\u00e3o, na verdade, uma combina\u00e7\u00e3o de v\u00e1rios linters que detectam problemas espec\u00edficos. Linting: flake8 \u00b6 A linguagem de program\u00e7\u00e3o Python possui v\u00e1rios linters. Um famoso, \u00e9 o flake8, capaz de detectar erros l\u00f3gicos e de estiliza\u00e7\u00e3o (PEP8), sendo uma combina\u00e7\u00e3o dos linters: PyFlakes pycodestyle (PEP8) Mccabe A instala\u00e7\u00e3o do flake8 \u00e9 simples, basta executarmos: pip install flake8 Se o seu ambiente de desenvolvimento possuir suporte para linting autom\u00e1tico (e.g. Visual Studio Code), os erros ser\u00e3o sinalizados no pr\u00f3prio ambiente. Caso contr\u00e1rio, podemos executar o linting especificamente nos arquivos desejados flake8 path/to/files/ Ainda, podem haver erros ou avisos que gostar\u00edamos de omitir por ser um falso-positivo ou que ao inv\u00e9s de contribuir para a melhoria da qualidade do c\u00f3digo, age ao contr\u00e1rio. Nesse caso, basta adicionamos a flag --ignore= seguido dos c\u00f3digos de erros que desejamos ignorar. flake8 --ignore = E1,E23,W503 path/to/files Se o objetivo for ignorar apenas linhas espec\u00edficas, basta incluirmos a flag # noqa: seguida dos c\u00f3digos de erro. example = lambda : 'example' # noqa: E731,E123 Dica Para ignorar todo e qualquer tipo de erro (ou aviso), use apenas # noqa Arquivos de Configura\u00e7\u00e3o \u00b6 A fim de garantir que todas as pessoas que estiverem trabalhando no mesmo projeto sigam as mesmas diretrizes, podemos definir as configura\u00e7\u00f5es do flake8 em arquivos de configura\u00e7\u00e3o na ra\u00edz do projeto. As configura\u00e7\u00f5es podem estar tanto em um arquivo .flake8 ou em setup.cfg ou tox.ini . Basta ent\u00e3o adicionar a chave [flake8] seguida das configura\u00e7\u00f5es desejadas. Por exemplo: [flake8] ignore = D203 exclude = .git, __pycache__, docs/source/conf.py, old, build, dist max-complexity = 10 Going Deeper \u00b6 No caso de linguagens tipadas dinamicamente, como Python, mas que suportam typing annotation , podemos usar ferramentas adicionais para garantir que os tipos, quando anotados, se comportam como o esperado. \u00c9 o caso da ferramenta mypy. Typing hinting com mypy \u00b6 Python \u00e9 uma linguagem dinamicamente tipada, logo as tipagens ocorrem em tempo de execu\u00e7\u00e3o (ou seja, conforme o c\u00f3digo \u00e9 executado). Por\u00e9m, h\u00e1 situa\u00e7\u00f5es em que queremos garantir que os tipos da vari\u00e1veis sejam respeitados, como, por exemplo, na passagem de par\u00e2metros para uma fun\u00e7\u00e3o ou no retorno desta. A ferramenta mypy \u00e9 uma type checker capaz de analisar e validar se as anota\u00e7\u00f5es de tipo s\u00e3o respeitadas com base nas PEP 484 e 526 . Para instalar o mypy , basta rodar pip install mypy Ent\u00e3o, para fazer a valida\u00e7\u00e3o das anota\u00e7\u00f5es de tipo, executamos: mypy script.py Nota O mypy i\u0155a executar toda a an\u00e1lise de forma est\u00e1tica. Isto \u00e9, assim como um linter, n\u00e3o ser\u00e1 executada qualquer linha de c\u00f3digo. Typing hinting com Pyright \u00b6 Pyright \u00e9 um type checker (assim como mypy) com foco em analisar grandes bases de c\u00f3digo Python, especialmente em modo \"watch\". As an\u00e1lises s\u00e3o feitas de forma incremental conforme os arquivos s\u00e3o modificados, possibilitando que grandes conjuntos de arquivos sejam verificados rapidamente, enquanto escritos. Ainda, o Pyright \u00e9 uma ferramenta integrada ao Pylance que, por sua vez, faz parte do ecossistema de extens\u00f5es Python da Microsoft para o Visual Studio Code. Para ativ\u00e1-lo no VSCode, basta abrir o painel de configura\u00e7\u00f5es e procurar por type checking . O resultado deve ser: Python \u203a Analysis: Type Checking Mode Defines the default rule set for type checking. As op\u00e7\u00f5es de regras s\u00e3o: basic . Checagem simples, sem muitas restri\u00e7\u00f5es. strict . Checagem completa, com diversas restri\u00e7\u00f5es e alta sensibilidade a poss\u00edveis erros. Tamb\u00e9m \u00e9 poss\u00edvel configurar o pyright via arquivo de configura\u00e7\u00f5es (e.g. settings.json ). Neste caso, basta adicionar ao arquivo: { \"python.analysis.typeCheckingMode\" : \"basic\" # or `s tr ic t ` } Typing hints podem ser legais? Para um material pr\u00e1tico sobre o uso de typing hints em Python, veja a se\u00e7\u00e3o Typing Hints Linting durante testes \u00b6 A fim de garantir que toda adi\u00e7\u00e3o ou altera\u00e7\u00e3o de c\u00f3digo no projeto respeite as conven\u00e7\u00f5es de estilo e padr\u00f5es de qualidade, podemos incluir a valida\u00e7\u00e3o de linters como uma etapa de teste (que \u00e9 executada durante um pipeline de CI/CD) ou mesmo antes de um commit ser feito (considerando que h\u00e1 o uso de Git). Para tal, podemos usar a ferramenta pre-commit , GitHub Actions ou GitLab CI/CD.","title":"Linters para Python"},{"location":"development_practices/linting/#linting","text":"","title":"Linting"},{"location":"development_practices/linting/#introducao","text":"Durante os momentos de escrita de c\u00f3digo podemos cometer uma s\u00e9rie de erros: Erros de sintaxe. Erros l\u00f3gicos que prejudicam a seguran\u00e7a da aplica\u00e7\u00e3o. Erros de estiliza\u00e7\u00e3o do c\u00f3digo. Por\u00e9m, tais erros s\u00e3o normais de acontecerem e, mesmo com muito esfor\u00e7o, \u00e9 dif\u00edcil encontrarmos todos eles. Portanto, utilizamos ferramentas capazes de analisar e detectar problemas em nossos c\u00f3digos. Essas ferramentas, chamadas de linters, s\u00e3o capazes de checar: Erros l\u00f3gicos (Logical Lint) Erros de sintaxe. Peda\u00e7os de c\u00f3digo com resultados indesejados (bugs). Peda\u00e7os de c\u00f3digo com falhas de seguran\u00e7a. Erros de estiliza\u00e7\u00e3o (Stylistic Lint) C\u00f3digo n\u00e3o alinhado com o Guia de Estilo definido. H\u00e1 tamb\u00e9m outras ferramentas que podemos usar em complemento aos linters que nos ajudam a melhorar a qualidade do c\u00f3digo, como \u00e9 o caso de formatadores autom\u00e1ticos de c\u00f3digo (code formatters). Nem tudo \u00e9 o que parece Na maioria dos casos, os linters que usamos s\u00e3o, na verdade, uma combina\u00e7\u00e3o de v\u00e1rios linters que detectam problemas espec\u00edficos.","title":"Introdu\u00e7\u00e3o"},{"location":"development_practices/linting/#linting-flake8","text":"A linguagem de program\u00e7\u00e3o Python possui v\u00e1rios linters. Um famoso, \u00e9 o flake8, capaz de detectar erros l\u00f3gicos e de estiliza\u00e7\u00e3o (PEP8), sendo uma combina\u00e7\u00e3o dos linters: PyFlakes pycodestyle (PEP8) Mccabe A instala\u00e7\u00e3o do flake8 \u00e9 simples, basta executarmos: pip install flake8 Se o seu ambiente de desenvolvimento possuir suporte para linting autom\u00e1tico (e.g. Visual Studio Code), os erros ser\u00e3o sinalizados no pr\u00f3prio ambiente. Caso contr\u00e1rio, podemos executar o linting especificamente nos arquivos desejados flake8 path/to/files/ Ainda, podem haver erros ou avisos que gostar\u00edamos de omitir por ser um falso-positivo ou que ao inv\u00e9s de contribuir para a melhoria da qualidade do c\u00f3digo, age ao contr\u00e1rio. Nesse caso, basta adicionamos a flag --ignore= seguido dos c\u00f3digos de erros que desejamos ignorar. flake8 --ignore = E1,E23,W503 path/to/files Se o objetivo for ignorar apenas linhas espec\u00edficas, basta incluirmos a flag # noqa: seguida dos c\u00f3digos de erro. example = lambda : 'example' # noqa: E731,E123 Dica Para ignorar todo e qualquer tipo de erro (ou aviso), use apenas # noqa","title":"Linting: flake8"},{"location":"development_practices/linting/#arquivos-de-configuracao","text":"A fim de garantir que todas as pessoas que estiverem trabalhando no mesmo projeto sigam as mesmas diretrizes, podemos definir as configura\u00e7\u00f5es do flake8 em arquivos de configura\u00e7\u00e3o na ra\u00edz do projeto. As configura\u00e7\u00f5es podem estar tanto em um arquivo .flake8 ou em setup.cfg ou tox.ini . Basta ent\u00e3o adicionar a chave [flake8] seguida das configura\u00e7\u00f5es desejadas. Por exemplo: [flake8] ignore = D203 exclude = .git, __pycache__, docs/source/conf.py, old, build, dist max-complexity = 10","title":"Arquivos de Configura\u00e7\u00e3o"},{"location":"development_practices/linting/#going-deeper","text":"No caso de linguagens tipadas dinamicamente, como Python, mas que suportam typing annotation , podemos usar ferramentas adicionais para garantir que os tipos, quando anotados, se comportam como o esperado. \u00c9 o caso da ferramenta mypy.","title":"Going Deeper"},{"location":"development_practices/linting/#typing-hinting-com-mypy","text":"Python \u00e9 uma linguagem dinamicamente tipada, logo as tipagens ocorrem em tempo de execu\u00e7\u00e3o (ou seja, conforme o c\u00f3digo \u00e9 executado). Por\u00e9m, h\u00e1 situa\u00e7\u00f5es em que queremos garantir que os tipos da vari\u00e1veis sejam respeitados, como, por exemplo, na passagem de par\u00e2metros para uma fun\u00e7\u00e3o ou no retorno desta. A ferramenta mypy \u00e9 uma type checker capaz de analisar e validar se as anota\u00e7\u00f5es de tipo s\u00e3o respeitadas com base nas PEP 484 e 526 . Para instalar o mypy , basta rodar pip install mypy Ent\u00e3o, para fazer a valida\u00e7\u00e3o das anota\u00e7\u00f5es de tipo, executamos: mypy script.py Nota O mypy i\u0155a executar toda a an\u00e1lise de forma est\u00e1tica. Isto \u00e9, assim como um linter, n\u00e3o ser\u00e1 executada qualquer linha de c\u00f3digo.","title":"Typing hinting com mypy"},{"location":"development_practices/linting/#typing-hinting-com-pyright","text":"Pyright \u00e9 um type checker (assim como mypy) com foco em analisar grandes bases de c\u00f3digo Python, especialmente em modo \"watch\". As an\u00e1lises s\u00e3o feitas de forma incremental conforme os arquivos s\u00e3o modificados, possibilitando que grandes conjuntos de arquivos sejam verificados rapidamente, enquanto escritos. Ainda, o Pyright \u00e9 uma ferramenta integrada ao Pylance que, por sua vez, faz parte do ecossistema de extens\u00f5es Python da Microsoft para o Visual Studio Code. Para ativ\u00e1-lo no VSCode, basta abrir o painel de configura\u00e7\u00f5es e procurar por type checking . O resultado deve ser: Python \u203a Analysis: Type Checking Mode Defines the default rule set for type checking. As op\u00e7\u00f5es de regras s\u00e3o: basic . Checagem simples, sem muitas restri\u00e7\u00f5es. strict . Checagem completa, com diversas restri\u00e7\u00f5es e alta sensibilidade a poss\u00edveis erros. Tamb\u00e9m \u00e9 poss\u00edvel configurar o pyright via arquivo de configura\u00e7\u00f5es (e.g. settings.json ). Neste caso, basta adicionar ao arquivo: { \"python.analysis.typeCheckingMode\" : \"basic\" # or `s tr ic t ` } Typing hints podem ser legais? Para um material pr\u00e1tico sobre o uso de typing hints em Python, veja a se\u00e7\u00e3o Typing Hints","title":"Typing hinting com Pyright"},{"location":"development_practices/linting/#linting-durante-testes","text":"A fim de garantir que toda adi\u00e7\u00e3o ou altera\u00e7\u00e3o de c\u00f3digo no projeto respeite as conven\u00e7\u00f5es de estilo e padr\u00f5es de qualidade, podemos incluir a valida\u00e7\u00e3o de linters como uma etapa de teste (que \u00e9 executada durante um pipeline de CI/CD) ou mesmo antes de um commit ser feito (considerando que h\u00e1 o uso de Git). Para tal, podemos usar a ferramenta pre-commit , GitHub Actions ou GitLab CI/CD.","title":"Linting durante testes"},{"location":"mastering_python/","text":"Masterizando o Python \u00b6","title":"Masterizando o Python"},{"location":"mastering_python/#masterizando-o-python","text":"","title":"Masterizando o Python"},{"location":"mastering_python/typing_hints/","text":"Typing Hints \u00b6","title":"Typing Hints"},{"location":"mastering_python/typing_hints/#typing-hints","text":"","title":"Typing Hints"},{"location":"mastering_python/definitive_guides/python_imports_guide/","text":"Guia de Importa\u00e7\u00f5es em Python \u00b6 Attention! Aten\u00e7\u00e3o! (en_US) This document is a translation and adaptation of the publication \"The Definitive Guide to Python import Statements\" by Chris Yeh . I just made a few tweaks for my own use. For complete instructions, visit the original publication! (pt_BR) Este documento \u00e9 uma tradua\u00e7\u00e3o e adapta\u00e7\u00e3o da publica\u00e7\u00e3o \"The Definitive Guide to Python import Statements\" de Chris Yeh . Eu apenas fiz alguns ajustes para uso pr\u00f3prio. Para instru\u00e7\u00f5es completas, visite a publica\u00e7\u00e3o original! Terminologia \u00b6 M\u00f3dulo. Todo e qualquer arquivo .py M\u00f3dulos Built-in : M\u00f3dulos padr\u00f5es da linguagem Python, geralmente escritos em C e traduzidos pra Python. Pacote. At\u00e9 o Python 3.3, qualquer diret\u00f3rio que contenha o arquivo __init__.py . A partir do Python 3.3, qualquer diret\u00f3rio que contenha ou n\u00e3o __init__.py Objeto. Tudo do Python Estrutura de Diret\u00f3rios (de Exemplo) \u00b6 test/ # root folder packA/ # package packA subA/ # subpackage subA __init__.py sa1.py sa2.py __init__.py a1.py a2.py packB/ # package packB (implicit namespace package) b1.py b2.py math.py random.py other.py start.py Sobre o import \u00b6 Quando executamos um .py (e.g. python foo.py ), o interpretador do Python busca todos os m\u00f3dulos ou pacotes na seguinte ordem: M\u00f3dulos Built-in M\u00f3dulos e pacotes import\u00e1veis atrav\u00e9s dos caminhos definidos em sys.path . A vari\u00e1vel sys.path \u00e9 uma lista de caminhos a partir do qual podemos importar pacotes ao executarmos o .py . Assim, a sys.path sempre \u00e9 inicializada com os seguintes caminhos: Diret\u00f3rio corrente onde o .py est\u00e1 sendo executado. Diret\u00f3rios contidos na vari\u00e1vel de ambiente PYTHONPATH . Diret\u00f3rios padr\u00f5es do sys.path . Ou seja: Python Standard Library, pacotes instalados no ambiente virtual, etc. Logo, apenas os pacotes contidos nos caminhos de sys.path s\u00e3o import\u00e1veis . Al\u00e9m disso, Se o (interpretador) Python for invocado iterativamente, sys.path[0] \u00e9 uma string vazia, indicando que os m\u00f3dulos e pacotes devem ser pesquisados atrav\u00e9s do diret\u00f3rio corrente (a partir do interpretador foi chamado). J\u00e1 se o script for executado da forma python foo.py , ent\u00e3o sys.path[0] \u00e9 o caminho absoluto para o script em quest\u00e3o. Portanto, perceba que quando executamos um script Python, pouco importa qual \u00e9 o caminho do seu \"diret\u00f3rio de trabalho\", o que importa \u00e9 o caminho do script . Exemplo Supondo que a localiza\u00e7\u00e3o do nosso shell estiver em test/ , se executarmos python ./packA/subA/sa1.py . sys.path[0] ser\u00e1 test/packA/subA/ , mas n\u00e3o test/ . Al\u00e9m disso, sys.path \u00e9 compartilhada entre todos os m\u00f3dulos import\u00e1veis! Exemplo Suponha que fa\u00e7amos user@user:~/test$ python start.py , onde # test/start.py from packA import a1 # test/packA/a1.py import sys print ( sys . path ) Com isso, sys.path[0] ser\u00e1 test/ e, portanto, o m\u00f3dulo a1.py ser\u00e1 capaz de importar todo e qualquer m\u00f3dulo e pacote que parte de test/ . Sobre o __init__.py \u00b6 O arquivo __init__.py tem dois pap\u00e9is: At\u00e9 o Python 3.3, __init__.py era respons\u00e1vel por tornar um pacote de scripts em um pacote de m\u00f3dulos import\u00e1veis. (Para toda e qualquer vers\u00e3o do Python) Respons\u00e1vel por executar o c\u00f3digo de inicializa\u00e7\u00e3o dos pacotes. Logo, para que os pacotes sejam considerados como m\u00f3dulos import\u00e1veis e inicializados apropriadamente (at\u00e9 o Python 3.3), devemos incluir o __init__.py no pacote em quest\u00e3o, como apresentado na estrutura de diret\u00f3rios . J\u00e1 para vers\u00f5es do Python superiores \u00e0 3.3, todos os diret\u00f3rios s\u00e3o considerados como pacotes, devido a ado\u00e7\u00e3o do pacotes de namespaces impl\u00edcitos. Inicializa\u00e7\u00e3o dos Pacotes \u00b6 Sempre que um pacote (ou um dos seus m\u00f3dulos) for importado, o Python executa todo o c\u00f3digo contido em __init__.py (presente na ra\u00edz do pacote), caso exista. Com isso, todos os objetos import\u00e1veis definidos em __init__.py s\u00e3o considerados parte do namespace do pacote 1 . Por exemplo, sejam: # test/packA/a1.py def a1_func (): print ( \"running a1_func()\" ) # test/packA/__init__.py # this import makes a1_func directly accessible from packA.a1_func from packA.a1 import a1_func from packA_func (): print ( \"running packA_func()\" ) # test/start.py import packA packA . packA_func () packA . a1_func () packA . a1 . a1_func () A sa\u00edda do comando user@user:~/test$ python start.py \u00e9: running packA_func () running a1_func () running a1_func () Sintaxe para Importa\u00e7\u00e3o de Objetos \u00b6 Como j\u00e1 visto anteriormente, podemos executar importa\u00e7\u00f5es de 3 formas diferentes import <package or module> Exemplo import numpy import <package or module> as alias Exemplo import numpy as np from <package or module> import <inner> Exemplo from numpy import random No primeiro caso, ap\u00f3s a importa\u00e7\u00e3o, basta navegarmos entre os diferentes n\u00edveis do pacote atrav\u00e9s da nota\u00e7\u00e3o de ponto. Por exemplo, pkgX.subpkgX.moduleX.X No segundo caso, definimos um \"apelido\" para o pacote ou m\u00f3dulo importado. Assim, podemos utiliz\u00e1-lo atrav\u00e9s do alias. J\u00e1 no terceiro caso, importamos um subpacote, m\u00f3dulo ou objeto mais interno do pacote principal. Note ainda que a nota\u00e7\u00e3o de ponto pode ser utilizada para importar diretamente os pacotes de interesse (em conjunto com from ). Por exemplo from pkgX.subpkgX.moduleX import X . Por fim, lembre que apenas os objetos declarados no __init__.py de cada pacote (ou subpacote) s\u00e3o import\u00e1veis. Importa\u00e7\u00e3o Absoluta vs Relativa \u00b6 Importa\u00e7\u00e3o absoluta \u00e9 aquela que usa o caminho absoluto (ou seja, a partir do diret\u00f3rio raiz do projeto) para o m\u00f3dulo que se deseja importar. Importa\u00e7\u00e3o relativa usa o caminho relativo (ou seja, a partir do m\u00f3dulo corrente) para o m\u00f3dulo que se deseja importar. Ainda, h\u00e1 dois tipos de importa\u00e7\u00e3o relativa . Importa\u00e7\u00e3o relativa expl\u00edcita . Importa\u00e7\u00f5es no formato from .<module or package> import X , onde . indica o diret\u00f3rio corrente; .. indica o diret\u00f3rio anterior, etc. Importa\u00e7\u00e3o relativa impl\u00edcita . Importa\u00e7\u00f5es definidas como se o diret\u00f3rio atual fosse parte de sys.path . Contudo, note que IMPORTA\u00c7\u00d5ES RELATIVAS IMPL\u00cdCITAS N\u00c3O EXISTEM NO PYTHON 3!!! Note ainda que, na importa\u00e7\u00e3o relativa conseguimos importar m\u00f3dulos apenas at\u00e9 o n\u00edvel a partir do qual estamos executando o .py . Portanto, \u00e9 recomendado o uso de importa\u00e7\u00e3o absoluta na grande maioria dos casos. Afinal, a importa\u00e7\u00e3o absoluta evita confus\u00f5es e inconsist\u00eancias. Al\u00e9m disso, scripts que usam importa\u00e7\u00e3o relativa n\u00e3o podem ser executados diretamente. Troubleshooting \u00b6 Uma das grandes vantagens da linguagem Python \u00e9 sua flexibilidade e durante o desenvolvimento de scripts tamb\u00e9m buscamos flexibilidade em como os m\u00f3dulos se relacionam entre si. Logo, seja para rodar um script diretamente ou importar um m\u00f3dulo dentro de outro, a flexibilidade \u00e9 importante. Por\u00e9m, o comportamento de importa\u00e7\u00e3o do Python produz algumas complica\u00e7\u00f5es especiais: Ao executarmos um script diretamente, \u00e9 imposs\u00edvel importar qualquer coisa de seu diret\u00f3rio-pai. O sys.path \u00e9 diferente para cada script, quando executados diretamente a partir da pasta em que cada um se encontra. Exemplo \u00b6 Vamos considerar a seguinte situa\u00e7\u00e3o. Dada nossa esturutra de diret\u00f3rios , queremos: Executar tanto o script start.py quanto a2.py diretamente. O start.py importa o m\u00f3dulo a2.py . O a2.py importa o m\u00f3dulo sa2.py . Problema \u00b6 Ao executarmos user@user:~test/$ python start.py , o sys.path ter\u00e1 test/ e as declara\u00e7\u00f5es de importa\u00e7\u00f5es ser\u00e3o: # test/start.py from packA import a2 # test/packA/a2.py from packA.subA import sa2 Por\u00e9m, ao executarmos user@user:~test/packA$ python a2.py , o sys.path ter\u00e1 test/packA/ . Logo: A declara\u00e7\u00e3o de importa\u00e7\u00e3o from packA.subA import sa2 n\u00e3o ir\u00e1 funcionar, pois packA n\u00e3o \u00e9 um diret\u00f3rio contido em test/packA/ . Se trocarmos a declara\u00e7\u00e3o para from subA import sa2 , ser\u00e1 poss\u00edvel executar python a2.py , mas imposs\u00edvel executar python start.py , pois n\u00e3o h\u00e1 subA/ em sys.path . Solu\u00e7\u00f5es (Workarounds) \u00b6 Consideando estes problemas, podemos recorrer \u00e0s seguintes estrat\u00e9gias: Use a importa\u00e7\u00e3o absoluta (sempre partindo da ra\u00edz, no caso test/ ) em todos os m\u00f3dulos, executando m\u00f3dulos mais internos a partir da ra\u00edz (recomendado) . Com isso, voc\u00ea ser\u00e1 capaz de executar o start.py diretamente. Para executar o a2.py diretamente, execute-o como um m\u00f3dulo: V\u00e1 para a raiz do diret\u00f3rio de trabalho Execute a2.py como um m\u00f3dulo importado python -m packA.a2 Use a importa\u00e7\u00e3o absoluta (sempre partindo da ra\u00edz, no caso test/ ) em todos os m\u00f3dulos, sendo o diret\u00f3rio ra\u00edz adicionado na sys.path . Com isso, voc\u00ea ser\u00e1 capaz de executar o start.py diretamente. Para executar o a2.py , adicione o diret\u00f3rio ra\u00edz test/ antes da importa\u00e7\u00e3o de sa2.py import os , sys sys . path . append ( os . path . dirname ( os . path . dirname ( os . path . realpath ( __file__ )))) from packA.subA import sa2 Nota Este m\u00e9todo funciona no geral. Contudo, h\u00e1 situa\u00e7\u00f5es em que a vari\u00e1vel __file__ pode estar incorreta. Neste caso, precisamos de uma solu\u00e7\u00e3o mais robusta. Acesse essa resposta no StackOverflow para mais instru\u00e7\u00f5es. Instale o pacote em modo de desenvolvimento no ambiente virtual. Com isso, a ra\u00edz do diret\u00f3rio sempre estar\u00e1 presente no sys.path como um pacote instalado (recomendado) . Dica Para informa\u00e7\u00f5es sobre cria\u00e7\u00e3o e instala\u00e7\u00e3o de pacotes, veja Criando Pacotes e M\u00f3dulos . Refer\u00eancias \u00b6 The Definitive Guide to Python import Statements Isso significa que podemos import\u00e1-los atrav\u00e9s da sintaxe pkgname.<obj_to_import> \u21a9","title":"Importa\u00e7\u00f5es em Python"},{"location":"mastering_python/definitive_guides/python_imports_guide/#guia-de-importacoes-em-python","text":"Attention! Aten\u00e7\u00e3o! (en_US) This document is a translation and adaptation of the publication \"The Definitive Guide to Python import Statements\" by Chris Yeh . I just made a few tweaks for my own use. For complete instructions, visit the original publication! (pt_BR) Este documento \u00e9 uma tradua\u00e7\u00e3o e adapta\u00e7\u00e3o da publica\u00e7\u00e3o \"The Definitive Guide to Python import Statements\" de Chris Yeh . Eu apenas fiz alguns ajustes para uso pr\u00f3prio. Para instru\u00e7\u00f5es completas, visite a publica\u00e7\u00e3o original!","title":"Guia de Importa\u00e7\u00f5es em Python"},{"location":"mastering_python/definitive_guides/python_imports_guide/#terminologia","text":"M\u00f3dulo. Todo e qualquer arquivo .py M\u00f3dulos Built-in : M\u00f3dulos padr\u00f5es da linguagem Python, geralmente escritos em C e traduzidos pra Python. Pacote. At\u00e9 o Python 3.3, qualquer diret\u00f3rio que contenha o arquivo __init__.py . A partir do Python 3.3, qualquer diret\u00f3rio que contenha ou n\u00e3o __init__.py Objeto. Tudo do Python","title":"Terminologia"},{"location":"mastering_python/definitive_guides/python_imports_guide/#estrutura-de-diretorios-de-exemplo","text":"test/ # root folder packA/ # package packA subA/ # subpackage subA __init__.py sa1.py sa2.py __init__.py a1.py a2.py packB/ # package packB (implicit namespace package) b1.py b2.py math.py random.py other.py start.py","title":"Estrutura de Diret\u00f3rios (de Exemplo)"},{"location":"mastering_python/definitive_guides/python_imports_guide/#sobre-o-import","text":"Quando executamos um .py (e.g. python foo.py ), o interpretador do Python busca todos os m\u00f3dulos ou pacotes na seguinte ordem: M\u00f3dulos Built-in M\u00f3dulos e pacotes import\u00e1veis atrav\u00e9s dos caminhos definidos em sys.path . A vari\u00e1vel sys.path \u00e9 uma lista de caminhos a partir do qual podemos importar pacotes ao executarmos o .py . Assim, a sys.path sempre \u00e9 inicializada com os seguintes caminhos: Diret\u00f3rio corrente onde o .py est\u00e1 sendo executado. Diret\u00f3rios contidos na vari\u00e1vel de ambiente PYTHONPATH . Diret\u00f3rios padr\u00f5es do sys.path . Ou seja: Python Standard Library, pacotes instalados no ambiente virtual, etc. Logo, apenas os pacotes contidos nos caminhos de sys.path s\u00e3o import\u00e1veis . Al\u00e9m disso, Se o (interpretador) Python for invocado iterativamente, sys.path[0] \u00e9 uma string vazia, indicando que os m\u00f3dulos e pacotes devem ser pesquisados atrav\u00e9s do diret\u00f3rio corrente (a partir do interpretador foi chamado). J\u00e1 se o script for executado da forma python foo.py , ent\u00e3o sys.path[0] \u00e9 o caminho absoluto para o script em quest\u00e3o. Portanto, perceba que quando executamos um script Python, pouco importa qual \u00e9 o caminho do seu \"diret\u00f3rio de trabalho\", o que importa \u00e9 o caminho do script . Exemplo Supondo que a localiza\u00e7\u00e3o do nosso shell estiver em test/ , se executarmos python ./packA/subA/sa1.py . sys.path[0] ser\u00e1 test/packA/subA/ , mas n\u00e3o test/ . Al\u00e9m disso, sys.path \u00e9 compartilhada entre todos os m\u00f3dulos import\u00e1veis! Exemplo Suponha que fa\u00e7amos user@user:~/test$ python start.py , onde # test/start.py from packA import a1 # test/packA/a1.py import sys print ( sys . path ) Com isso, sys.path[0] ser\u00e1 test/ e, portanto, o m\u00f3dulo a1.py ser\u00e1 capaz de importar todo e qualquer m\u00f3dulo e pacote que parte de test/ .","title":"Sobre o import"},{"location":"mastering_python/definitive_guides/python_imports_guide/#sobre-o-__init__py","text":"O arquivo __init__.py tem dois pap\u00e9is: At\u00e9 o Python 3.3, __init__.py era respons\u00e1vel por tornar um pacote de scripts em um pacote de m\u00f3dulos import\u00e1veis. (Para toda e qualquer vers\u00e3o do Python) Respons\u00e1vel por executar o c\u00f3digo de inicializa\u00e7\u00e3o dos pacotes. Logo, para que os pacotes sejam considerados como m\u00f3dulos import\u00e1veis e inicializados apropriadamente (at\u00e9 o Python 3.3), devemos incluir o __init__.py no pacote em quest\u00e3o, como apresentado na estrutura de diret\u00f3rios . J\u00e1 para vers\u00f5es do Python superiores \u00e0 3.3, todos os diret\u00f3rios s\u00e3o considerados como pacotes, devido a ado\u00e7\u00e3o do pacotes de namespaces impl\u00edcitos.","title":"Sobre o __init__.py"},{"location":"mastering_python/definitive_guides/python_imports_guide/#inicializacao-dos-pacotes","text":"Sempre que um pacote (ou um dos seus m\u00f3dulos) for importado, o Python executa todo o c\u00f3digo contido em __init__.py (presente na ra\u00edz do pacote), caso exista. Com isso, todos os objetos import\u00e1veis definidos em __init__.py s\u00e3o considerados parte do namespace do pacote 1 . Por exemplo, sejam: # test/packA/a1.py def a1_func (): print ( \"running a1_func()\" ) # test/packA/__init__.py # this import makes a1_func directly accessible from packA.a1_func from packA.a1 import a1_func from packA_func (): print ( \"running packA_func()\" ) # test/start.py import packA packA . packA_func () packA . a1_func () packA . a1 . a1_func () A sa\u00edda do comando user@user:~/test$ python start.py \u00e9: running packA_func () running a1_func () running a1_func ()","title":"Inicializa\u00e7\u00e3o dos Pacotes"},{"location":"mastering_python/definitive_guides/python_imports_guide/#sintaxe-para-importacao-de-objetos","text":"Como j\u00e1 visto anteriormente, podemos executar importa\u00e7\u00f5es de 3 formas diferentes import <package or module> Exemplo import numpy import <package or module> as alias Exemplo import numpy as np from <package or module> import <inner> Exemplo from numpy import random No primeiro caso, ap\u00f3s a importa\u00e7\u00e3o, basta navegarmos entre os diferentes n\u00edveis do pacote atrav\u00e9s da nota\u00e7\u00e3o de ponto. Por exemplo, pkgX.subpkgX.moduleX.X No segundo caso, definimos um \"apelido\" para o pacote ou m\u00f3dulo importado. Assim, podemos utiliz\u00e1-lo atrav\u00e9s do alias. J\u00e1 no terceiro caso, importamos um subpacote, m\u00f3dulo ou objeto mais interno do pacote principal. Note ainda que a nota\u00e7\u00e3o de ponto pode ser utilizada para importar diretamente os pacotes de interesse (em conjunto com from ). Por exemplo from pkgX.subpkgX.moduleX import X . Por fim, lembre que apenas os objetos declarados no __init__.py de cada pacote (ou subpacote) s\u00e3o import\u00e1veis.","title":"Sintaxe para Importa\u00e7\u00e3o de Objetos"},{"location":"mastering_python/definitive_guides/python_imports_guide/#importacao-absoluta-vs-relativa","text":"Importa\u00e7\u00e3o absoluta \u00e9 aquela que usa o caminho absoluto (ou seja, a partir do diret\u00f3rio raiz do projeto) para o m\u00f3dulo que se deseja importar. Importa\u00e7\u00e3o relativa usa o caminho relativo (ou seja, a partir do m\u00f3dulo corrente) para o m\u00f3dulo que se deseja importar. Ainda, h\u00e1 dois tipos de importa\u00e7\u00e3o relativa . Importa\u00e7\u00e3o relativa expl\u00edcita . Importa\u00e7\u00f5es no formato from .<module or package> import X , onde . indica o diret\u00f3rio corrente; .. indica o diret\u00f3rio anterior, etc. Importa\u00e7\u00e3o relativa impl\u00edcita . Importa\u00e7\u00f5es definidas como se o diret\u00f3rio atual fosse parte de sys.path . Contudo, note que IMPORTA\u00c7\u00d5ES RELATIVAS IMPL\u00cdCITAS N\u00c3O EXISTEM NO PYTHON 3!!! Note ainda que, na importa\u00e7\u00e3o relativa conseguimos importar m\u00f3dulos apenas at\u00e9 o n\u00edvel a partir do qual estamos executando o .py . Portanto, \u00e9 recomendado o uso de importa\u00e7\u00e3o absoluta na grande maioria dos casos. Afinal, a importa\u00e7\u00e3o absoluta evita confus\u00f5es e inconsist\u00eancias. Al\u00e9m disso, scripts que usam importa\u00e7\u00e3o relativa n\u00e3o podem ser executados diretamente.","title":"Importa\u00e7\u00e3o Absoluta vs Relativa"},{"location":"mastering_python/definitive_guides/python_imports_guide/#troubleshooting","text":"Uma das grandes vantagens da linguagem Python \u00e9 sua flexibilidade e durante o desenvolvimento de scripts tamb\u00e9m buscamos flexibilidade em como os m\u00f3dulos se relacionam entre si. Logo, seja para rodar um script diretamente ou importar um m\u00f3dulo dentro de outro, a flexibilidade \u00e9 importante. Por\u00e9m, o comportamento de importa\u00e7\u00e3o do Python produz algumas complica\u00e7\u00f5es especiais: Ao executarmos um script diretamente, \u00e9 imposs\u00edvel importar qualquer coisa de seu diret\u00f3rio-pai. O sys.path \u00e9 diferente para cada script, quando executados diretamente a partir da pasta em que cada um se encontra.","title":"Troubleshooting"},{"location":"mastering_python/definitive_guides/python_imports_guide/#exemplo","text":"Vamos considerar a seguinte situa\u00e7\u00e3o. Dada nossa esturutra de diret\u00f3rios , queremos: Executar tanto o script start.py quanto a2.py diretamente. O start.py importa o m\u00f3dulo a2.py . O a2.py importa o m\u00f3dulo sa2.py .","title":"Exemplo"},{"location":"mastering_python/definitive_guides/python_imports_guide/#problema","text":"Ao executarmos user@user:~test/$ python start.py , o sys.path ter\u00e1 test/ e as declara\u00e7\u00f5es de importa\u00e7\u00f5es ser\u00e3o: # test/start.py from packA import a2 # test/packA/a2.py from packA.subA import sa2 Por\u00e9m, ao executarmos user@user:~test/packA$ python a2.py , o sys.path ter\u00e1 test/packA/ . Logo: A declara\u00e7\u00e3o de importa\u00e7\u00e3o from packA.subA import sa2 n\u00e3o ir\u00e1 funcionar, pois packA n\u00e3o \u00e9 um diret\u00f3rio contido em test/packA/ . Se trocarmos a declara\u00e7\u00e3o para from subA import sa2 , ser\u00e1 poss\u00edvel executar python a2.py , mas imposs\u00edvel executar python start.py , pois n\u00e3o h\u00e1 subA/ em sys.path .","title":"Problema"},{"location":"mastering_python/definitive_guides/python_imports_guide/#solucoes-workarounds","text":"Consideando estes problemas, podemos recorrer \u00e0s seguintes estrat\u00e9gias: Use a importa\u00e7\u00e3o absoluta (sempre partindo da ra\u00edz, no caso test/ ) em todos os m\u00f3dulos, executando m\u00f3dulos mais internos a partir da ra\u00edz (recomendado) . Com isso, voc\u00ea ser\u00e1 capaz de executar o start.py diretamente. Para executar o a2.py diretamente, execute-o como um m\u00f3dulo: V\u00e1 para a raiz do diret\u00f3rio de trabalho Execute a2.py como um m\u00f3dulo importado python -m packA.a2 Use a importa\u00e7\u00e3o absoluta (sempre partindo da ra\u00edz, no caso test/ ) em todos os m\u00f3dulos, sendo o diret\u00f3rio ra\u00edz adicionado na sys.path . Com isso, voc\u00ea ser\u00e1 capaz de executar o start.py diretamente. Para executar o a2.py , adicione o diret\u00f3rio ra\u00edz test/ antes da importa\u00e7\u00e3o de sa2.py import os , sys sys . path . append ( os . path . dirname ( os . path . dirname ( os . path . realpath ( __file__ )))) from packA.subA import sa2 Nota Este m\u00e9todo funciona no geral. Contudo, h\u00e1 situa\u00e7\u00f5es em que a vari\u00e1vel __file__ pode estar incorreta. Neste caso, precisamos de uma solu\u00e7\u00e3o mais robusta. Acesse essa resposta no StackOverflow para mais instru\u00e7\u00f5es. Instale o pacote em modo de desenvolvimento no ambiente virtual. Com isso, a ra\u00edz do diret\u00f3rio sempre estar\u00e1 presente no sys.path como um pacote instalado (recomendado) . Dica Para informa\u00e7\u00f5es sobre cria\u00e7\u00e3o e instala\u00e7\u00e3o de pacotes, veja Criando Pacotes e M\u00f3dulos .","title":"Solu\u00e7\u00f5es (Workarounds)"},{"location":"mastering_python/definitive_guides/python_imports_guide/#referencias","text":"The Definitive Guide to Python import Statements Isso significa que podemos import\u00e1-los atrav\u00e9s da sintaxe pkgname.<obj_to_import> \u21a9","title":"Refer\u00eancias"},{"location":"oriented_object_programming/","text":"Python OOP in a Nutshell \u00b6 Este reposit\u00f3rio cont\u00e9m um conjunto de Jupyter Notebooks que explicam sobre Programa\u00e7\u00e3o Orientada \u00e0 Objetos em Python, boas pr\u00e1ticas e receitas. O trabalho ainda est\u00e1 em progresso. Portanto, erros ser\u00e3o corrigidos e melhorias adicionadas \u00e0 medida que o trabalho avan\u00e7ar. Caso queira contribuir com sugest\u00f5es, sinta-se \u00e0 vontade para abrir Issues & PRs!","title":"Python OOP in a Nutshell"},{"location":"oriented_object_programming/#python-oop-in-a-nutshell","text":"Este reposit\u00f3rio cont\u00e9m um conjunto de Jupyter Notebooks que explicam sobre Programa\u00e7\u00e3o Orientada \u00e0 Objetos em Python, boas pr\u00e1ticas e receitas. O trabalho ainda est\u00e1 em progresso. Portanto, erros ser\u00e3o corrigidos e melhorias adicionadas \u00e0 medida que o trabalho avan\u00e7ar. Caso queira contribuir com sugest\u00f5es, sinta-se \u00e0 vontade para abrir Issues & PRs!","title":"Python OOP in a Nutshell"},{"location":"oriented_object_programming/classes_and_objects_in_python/","text":"Classes e Objetos em Python \u00b6 Manter um material \"code-heavy\" sobre Python em Markdown ia dar um trabalh\u00e3o chato. Ent\u00e3o, para facilitar a coisa toda, o material dessa se\u00e7\u00e3o est\u00e1 no Jupyter notebook Classes e Objetos em Python ! Checa l\u00e1!","title":"Classes e Objetos"},{"location":"oriented_object_programming/classes_and_objects_in_python/#classes-e-objetos-em-python","text":"Manter um material \"code-heavy\" sobre Python em Markdown ia dar um trabalh\u00e3o chato. Ent\u00e3o, para facilitar a coisa toda, o material dessa se\u00e7\u00e3o est\u00e1 no Jupyter notebook Classes e Objetos em Python ! Checa l\u00e1!","title":"Classes e Objetos em Python"},{"location":"oriented_object_programming/inheritance_composition_and_polymorphism/","text":"Heran\u00e7a e Composi\u00e7\u00e3o \u00b6 Manter um material \"code-heavy\" sobre Python em Markdown ia dar um trabalh\u00e3o chato. Ent\u00e3o, para facilitar a coisa toda, o material dessa se\u00e7\u00e3o est\u00e1 no Jupyter notebook Heran\u00e7a e Composi\u00e7\u00e3o ! Checa l\u00e1!","title":"Heran\u00e7a, Composi\u00e7\u00e3o & Polimorfismo"},{"location":"oriented_object_programming/inheritance_composition_and_polymorphism/#heranca-e-composicao","text":"Manter um material \"code-heavy\" sobre Python em Markdown ia dar um trabalh\u00e3o chato. Ent\u00e3o, para facilitar a coisa toda, o material dessa se\u00e7\u00e3o est\u00e1 no Jupyter notebook Heran\u00e7a e Composi\u00e7\u00e3o ! Checa l\u00e1!","title":"Heran\u00e7a e Composi\u00e7\u00e3o"},{"location":"oriented_object_programming/introduction/","text":"Introdu\u00e7\u00e3o ao Design Orientado \u00e0 Objetos \u00b6","title":"Introdu\u00e7\u00e3o ao Design Orientado \u00e0 Objetos"},{"location":"oriented_object_programming/introduction/#introducao-ao-design-orientado-a-objetos","text":"","title":"Introdu\u00e7\u00e3o ao Design Orientado \u00e0 Objetos"},{"location":"oriented_object_programming/cases/","text":"","title":"Index"}]}